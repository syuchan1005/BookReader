/* This file generated by @graphql-codegen */
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type BigInt = number;
export type IntRange = (number | [number, number])[];
export type Upload = File;
const defaultOptions =  {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  BigInt: BigInt;
  IntRange: IntRange;
  Upload: Upload;
};


export type Book = {
  __typename?: 'Book';
  id: Scalars['ID'];
  thumbnail?: Maybe<Scalars['Int']>;
  number: Scalars['String'];
  pages: Scalars['Int'];
  updatedAt: Scalars['String'];
  info?: Maybe<BookInfo>;
};

export type BookInfo = {
  __typename?: 'BookInfo';
  id: Scalars['ID'];
  name: Scalars['String'];
  thumbnail?: Maybe<BookInfoThumbnail>;
  count: Scalars['Int'];
  history: Scalars['Boolean'];
  genres: Array<Genre>;
  updatedAt: Scalars['String'];
  books: Array<Book>;
};


export type BookInfoBooksArgs = {
  order?: Maybe<BookOrder>;
};

export type BookInfoEdge = {
  __typename?: 'BookInfoEdge';
  cursor: Scalars['String'];
  node: BookInfo;
};

export type BookInfoHistory = {
  name: Scalars['String'];
  count: Scalars['Int'];
};

export type BookInfoList = {
  __typename?: 'BookInfoList';
  hasNext: Scalars['Boolean'];
  infos: Array<BookInfo>;
};

export enum BookInfoOrder {
  UpdateNewest = 'Update_Newest',
  UpdateOldest = 'Update_Oldest',
  AddNewest = 'Add_Newest',
  AddOldest = 'Add_Oldest',
  NameAsc = 'Name_Asc',
  NameDesc = 'Name_Desc'
}

export type BookInfoPartialList = {
  __typename?: 'BookInfoPartialList';
  pageInfo: PageInfo;
  edges: Array<BookInfoEdge>;
};

export type BookInfoResult = {
  __typename?: 'BookInfoResult';
  success: Scalars['Boolean'];
  code?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  books: Array<Book>;
};

export type BookInfoThumbnail = {
  __typename?: 'BookInfoThumbnail';
  bookId: Scalars['ID'];
  pageIndex: Scalars['Int'];
  bookPageCount: Scalars['Int'];
};

export type BookInfosOption = {
  search?: Maybe<Scalars['String']>;
  genres?: Maybe<Array<Scalars['String']>>;
  history?: Maybe<HistoryType>;
  order?: Maybe<BookInfoOrder>;
};

export enum BookOrder {
  UpdateNewest = 'Update_Newest',
  UpdateOldest = 'Update_Oldest',
  NumberAsc = 'Number_Asc',
  NumberDesc = 'Number_Desc'
}

export type CommonPluginQuery = {
  __typename?: 'CommonPluginQuery';
  name: Scalars['String'];
  args: Array<Scalars['String']>;
  subscription?: Maybe<Scalars['Boolean']>;
};

export type CropEditAction = {
  pageRange: Scalars['IntRange'];
  left?: Maybe<Scalars['Int']>;
  right?: Maybe<Scalars['Int']>;
  top?: Maybe<Scalars['Int']>;
  bottom?: Maybe<Scalars['Int']>;
};

export type Debug_FolderSizes = {
  __typename?: 'Debug_FolderSizes';
  tmp: Scalars['BigInt'];
  cache: Scalars['BigInt'];
  book: Scalars['BigInt'];
  unusedBook: Scalars['BigInt'];
  bookInfoCount: Scalars['Int'];
  bookCount: Scalars['Int'];
};

export type DeleteEditAction = {
  pageRange: Scalars['IntRange'];
};

export type EditAction = {
  editType: EditType;
  crop?: Maybe<CropEditAction>;
  replace?: Maybe<UploadEditAction>;
  delete?: Maybe<DeleteEditAction>;
  put?: Maybe<UploadEditAction>;
  split?: Maybe<SplitEditAction>;
};

export enum EditType {
  Crop = 'Crop',
  Replace = 'Replace',
  Delete = 'Delete',
  Put = 'Put',
  Split = 'Split'
}

export type Genre = {
  __typename?: 'Genre';
  name: Scalars['ID'];
  invisible: Scalars['Boolean'];
};

export enum HistoryType {
  All = 'ALL',
  HistoryOnly = 'HISTORY_ONLY',
  NormalOnly = 'NORMAL_ONLY'
}

export type InputBook = {
  number: Scalars['String'];
  file?: Maybe<Scalars['Upload']>;
  path?: Maybe<Scalars['String']>;
};


export type Mutation = {
  __typename?: 'Mutation';
  addBookInfo: ResultWithInfoId;
  editBookInfo: Result;
  deleteBookInfo: BookInfoResult;
  addBookInfoHistories: Result;
  addBooks: Array<Result>;
  addCompressBook: ResultWithBookResults;
  editBook: Result;
  deleteBooks: Result;
  moveBooks: Result;
  bulkEditPage: Result;
  deleteGenre: Result;
  editGenre: Result;
  debug_deleteUnusedFolders: Result;
};


export type MutationAddBookInfoArgs = {
  name: Scalars['String'];
  genres?: Maybe<Array<Scalars['String']>>;
};


export type MutationEditBookInfoArgs = {
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  thumbnail?: Maybe<Scalars['ID']>;
  genres?: Maybe<Array<Scalars['String']>>;
};


export type MutationDeleteBookInfoArgs = {
  id: Scalars['ID'];
};


export type MutationAddBookInfoHistoriesArgs = {
  histories: Array<BookInfoHistory>;
};


export type MutationAddBooksArgs = {
  id: Scalars['ID'];
  books: Array<InputBook>;
};


export type MutationAddCompressBookArgs = {
  id: Scalars['ID'];
  file?: Maybe<Scalars['Upload']>;
  path?: Maybe<Scalars['String']>;
};


export type MutationEditBookArgs = {
  id: Scalars['ID'];
  number?: Maybe<Scalars['String']>;
  thumbnail?: Maybe<Scalars['Int']>;
};


export type MutationDeleteBooksArgs = {
  infoId: Scalars['ID'];
  ids: Array<Scalars['ID']>;
};


export type MutationMoveBooksArgs = {
  infoId: Scalars['ID'];
  ids: Array<Scalars['ID']>;
};


export type MutationBulkEditPageArgs = {
  id: Scalars['ID'];
  actions: Array<EditAction>;
};


export type MutationDeleteGenreArgs = {
  genre: Scalars['String'];
};


export type MutationEditGenreArgs = {
  oldName: Scalars['String'];
  newName?: Maybe<Scalars['String']>;
  invisible?: Maybe<Scalars['Boolean']>;
};

export type PageInfo = {
  __typename?: 'PageInfo';
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor: Scalars['String'];
  endCursor: Scalars['String'];
};

export type Plugin = {
  __typename?: 'Plugin';
  info: PluginInfo;
  queries: PluginQueries;
};

export type PluginInfo = {
  __typename?: 'PluginInfo';
  name: Scalars['String'];
  version: Scalars['String'];
};

export type PluginQueries = {
  __typename?: 'PluginQueries';
  add: CommonPluginQuery;
};

export type Query = {
  __typename?: 'Query';
  relayBookInfos: BookInfoPartialList;
  bookInfo?: Maybe<BookInfo>;
  book?: Maybe<Book>;
  debug_folderSize: Debug_FolderSizes;
  plugins: Array<Plugin>;
  genres: Array<Genre>;
};


export type QueryRelayBookInfosArgs = {
  first?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  option?: Maybe<BookInfosOption>;
};


export type QueryBookInfoArgs = {
  id: Scalars['ID'];
};


export type QueryBookArgs = {
  id: Scalars['ID'];
};

export type Result = {
  __typename?: 'Result';
  success: Scalars['Boolean'];
  code?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
};

export type ResultWithBookResults = {
  __typename?: 'ResultWithBookResults';
  success: Scalars['Boolean'];
  code?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  bookResults?: Maybe<Array<Result>>;
};

export type ResultWithInfoId = {
  __typename?: 'ResultWithInfoId';
  success: Scalars['Boolean'];
  code?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  infoId?: Maybe<Scalars['ID']>;
};

export type SplitEditAction = {
  pageRange: Scalars['IntRange'];
  splitType: SplitType;
  splitCount?: Maybe<Scalars['Int']>;
};

export enum SplitType {
  Vertical = 'VERTICAL',
  Horizontal = 'HORIZONTAL'
}

export type Subscription = {
  __typename?: 'Subscription';
  addBooks: Scalars['String'];
};


export type SubscriptionAddBooksArgs = {
  id: Scalars['ID'];
};


export type UploadEditAction = {
  pageIndex: Scalars['Int'];
  image: Scalars['Upload'];
};

export type AddBooksMutationVariables = Exact<{
  id: Scalars['ID'];
  books: Array<InputBook> | InputBook;
}>;


export type AddBooksMutation = (
  { __typename?: 'Mutation' }
  & { adds: Array<(
    { __typename?: 'Result' }
    & Pick<Result, 'success' | 'code'>
  )> }
);

export type AddBooksProgressSubscriptionVariables = Exact<{
  id: Scalars['ID'];
}>;


export type AddBooksProgressSubscription = (
  { __typename?: 'Subscription' }
  & Pick<Subscription, 'addBooks'>
);

export type AddCompressBookMutationVariables = Exact<{
  id: Scalars['ID'];
  file?: Maybe<Scalars['Upload']>;
  path?: Maybe<Scalars['String']>;
}>;


export type AddCompressBookMutation = (
  { __typename?: 'Mutation' }
  & { add: (
    { __typename?: 'ResultWithBookResults' }
    & Pick<ResultWithBookResults, 'success' | 'code'>
  ) }
);

export type PluginsQueryVariables = Exact<{ [key: string]: never; }>;


export type PluginsQuery = (
  { __typename?: 'Query' }
  & { plugins: Array<(
    { __typename?: 'Plugin' }
    & { info: (
      { __typename?: 'PluginInfo' }
      & Pick<PluginInfo, 'name'>
    ), queries: (
      { __typename?: 'PluginQueries' }
      & { add: (
        { __typename?: 'CommonPluginQuery' }
        & Pick<CommonPluginQuery, 'name' | 'args' | 'subscription'>
      ) }
    ) }
  )> }
);

export type AddBookInfoMutationVariables = Exact<{
  name: Scalars['String'];
  genres: Array<Scalars['String']> | Scalars['String'];
}>;


export type AddBookInfoMutation = (
  { __typename?: 'Mutation' }
  & { add: (
    { __typename?: 'ResultWithInfoId' }
    & Pick<ResultWithInfoId, 'success' | 'code'>
  ) }
);

export type AddBookInfoHistoriesMutationVariables = Exact<{
  histories: Array<BookInfoHistory> | BookInfoHistory;
}>;


export type AddBookInfoHistoriesMutation = (
  { __typename?: 'Mutation' }
  & { add: (
    { __typename?: 'Result' }
    & Pick<Result, 'success' | 'code'>
  ) }
);

export type DeleteUnusedFoldersMutationVariables = Exact<{ [key: string]: never; }>;


export type DeleteUnusedFoldersMutation = (
  { __typename?: 'Mutation' }
  & { debug_deleteUnusedFolders: (
    { __typename?: 'Result' }
    & Pick<Result, 'success' | 'code'>
  ) }
);

export type FolderSizesQueryVariables = Exact<{ [key: string]: never; }>;


export type FolderSizesQuery = (
  { __typename?: 'Query' }
  & { sizes: (
    { __typename?: 'Debug_FolderSizes' }
    & Pick<Debug_FolderSizes, 'tmp' | 'cache' | 'book' | 'unusedBook' | 'bookInfoCount' | 'bookCount'>
  ) }
);

export type DeleteBookInfoMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteBookInfoMutation = (
  { __typename?: 'Mutation' }
  & { del: (
    { __typename?: 'BookInfoResult' }
    & Pick<BookInfoResult, 'success' | 'code'>
    & { books: Array<(
      { __typename?: 'Book' }
      & Pick<Book, 'id' | 'pages'>
    )> }
  ) }
);

export type EditBookInfoMutationVariables = Exact<{
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  genres: Array<Scalars['String']> | Scalars['String'];
}>;


export type EditBookInfoMutation = (
  { __typename?: 'Mutation' }
  & { edit: (
    { __typename?: 'Result' }
    & Pick<Result, 'success' | 'code'>
  ) }
);

export type EditBookMutationVariables = Exact<{
  id: Scalars['ID'];
  number?: Maybe<Scalars['String']>;
}>;


export type EditBookMutation = (
  { __typename?: 'Mutation' }
  & { edit: (
    { __typename?: 'Result' }
    & Pick<Result, 'success' | 'code'>
  ) }
);

export type DownloadBookInfosQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DownloadBookInfosQuery = (
  { __typename?: 'Query' }
  & { bookInfo?: Maybe<(
    { __typename?: 'BookInfo' }
    & Pick<BookInfo, 'id' | 'name' | 'count'>
    & { books: Array<(
      { __typename?: 'Book' }
      & Pick<Book, 'id' | 'number' | 'pages'>
    )> }
  )> }
);

export type BulkEditPagesMutationVariables = Exact<{
  bookId: Scalars['ID'];
  editActions: Array<EditAction> | EditAction;
}>;


export type BulkEditPagesMutation = (
  { __typename?: 'Mutation' }
  & { bulkEditPage: (
    { __typename?: 'Result' }
    & Pick<Result, 'success' | 'code' | 'message'>
  ) }
);

export type BookQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type BookQuery = (
  { __typename?: 'Query' }
  & { book?: Maybe<(
    { __typename?: 'Book' }
    & Pick<Book, 'id' | 'number' | 'pages'>
    & { info?: Maybe<(
      { __typename?: 'BookInfo' }
      & Pick<BookInfo, 'id' | 'name'>
    )> }
  )> }
);

export type RelayBookInfosQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  option: BookInfosOption;
}>;


export type RelayBookInfosQuery = (
  { __typename?: 'Query' }
  & { bookInfos: (
    { __typename?: 'BookInfoPartialList' }
    & { edges: Array<(
      { __typename?: 'BookInfoEdge' }
      & Pick<BookInfoEdge, 'cursor'>
      & { node: (
        { __typename?: 'BookInfo' }
        & Pick<BookInfo, 'id' | 'name' | 'count' | 'history' | 'updatedAt'>
        & { thumbnail?: Maybe<(
          { __typename?: 'BookInfoThumbnail' }
          & Pick<BookInfoThumbnail, 'bookId' | 'pageIndex' | 'bookPageCount'>
        )>, genres: Array<(
          { __typename?: 'Genre' }
          & Pick<Genre, 'name' | 'invisible'>
        )> }
      ) }
    )>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'>
    ) }
  ) }
);

export type DeleteGenreMutationVariables = Exact<{
  name: Scalars['String'];
}>;


export type DeleteGenreMutation = (
  { __typename?: 'Mutation' }
  & { deleteGenre: (
    { __typename?: 'Result' }
    & Pick<Result, 'code' | 'success' | 'message'>
  ) }
);

export type EditGenreMutationVariables = Exact<{
  oldName: Scalars['String'];
  newName?: Maybe<Scalars['String']>;
  invisible?: Maybe<Scalars['Boolean']>;
}>;


export type EditGenreMutation = (
  { __typename?: 'Mutation' }
  & { editGenre: (
    { __typename?: 'Result' }
    & Pick<Result, 'code' | 'success' | 'message'>
  ) }
);

export type DeleteBooksMutationVariables = Exact<{
  infoId: Scalars['ID'];
  ids: Array<Scalars['ID']> | Scalars['ID'];
}>;


export type DeleteBooksMutation = (
  { __typename?: 'Mutation' }
  & { deleteBooks: (
    { __typename?: 'Result' }
    & Pick<Result, 'success' | 'code'>
  ) }
);

export type MoveBooksMutationVariables = Exact<{
  infoId: Scalars['ID'];
  ids: Array<Scalars['ID']> | Scalars['ID'];
}>;


export type MoveBooksMutation = (
  { __typename?: 'Mutation' }
  & { moveBooks: (
    { __typename?: 'Result' }
    & Pick<Result, 'success' | 'code'>
  ) }
);

export type EditBookInfoThumbnailMutationVariables = Exact<{
  id: Scalars['ID'];
  thumbnail?: Maybe<Scalars['ID']>;
}>;


export type EditBookInfoThumbnailMutation = (
  { __typename?: 'Mutation' }
  & { edit: (
    { __typename?: 'Result' }
    & Pick<Result, 'success' | 'code'>
  ) }
);

export type BookPagesQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type BookPagesQuery = (
  { __typename?: 'Query' }
  & { book?: Maybe<(
    { __typename?: 'Book' }
    & Pick<Book, 'id' | 'pages'>
  )> }
);

export type EditBookThumbnailMutationVariables = Exact<{
  id: Scalars['ID'];
  th?: Maybe<Scalars['Int']>;
}>;


export type EditBookThumbnailMutation = (
  { __typename?: 'Mutation' }
  & { edit: (
    { __typename?: 'Result' }
    & Pick<Result, 'success' | 'code'>
  ) }
);

export type BookInfoQueryVariables = Exact<{
  id: Scalars['ID'];
  order?: Maybe<BookOrder>;
}>;


export type BookInfoQuery = (
  { __typename?: 'Query' }
  & { bookInfo?: Maybe<(
    { __typename?: 'BookInfo' }
    & Pick<BookInfo, 'id' | 'name'>
    & { books: Array<(
      { __typename?: 'Book' }
      & Pick<Book, 'id' | 'number' | 'pages' | 'thumbnail' | 'updatedAt'>
      & { info?: Maybe<(
        { __typename?: 'BookInfo' }
        & Pick<BookInfo, 'id'>
      )> }
    )> }
  )> }
);

export type GenresQueryVariables = Exact<{ [key: string]: never; }>;


export type GenresQuery = (
  { __typename?: 'Query' }
  & { genres: Array<(
    { __typename?: 'Genre' }
    & Pick<Genre, 'name' | 'invisible'>
  )> }
);


export const AddBooksDocument = gql`
    mutation addBooks($id: ID!, $books: [InputBook!]!) {
  adds: addBooks(id: $id, books: $books) {
    success
    code
  }
}
    `;
export type AddBooksMutationFn = Apollo.MutationFunction<AddBooksMutation, AddBooksMutationVariables>;

/**
 * __useAddBooksMutation__
 *
 * To run a mutation, you first call `useAddBooksMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddBooksMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addBooksMutation, { data, loading, error }] = useAddBooksMutation({
 *   variables: {
 *      id: // value for 'id'
 *      books: // value for 'books'
 *   },
 * });
 */
export function useAddBooksMutation(baseOptions?: Apollo.MutationHookOptions<AddBooksMutation, AddBooksMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddBooksMutation, AddBooksMutationVariables>(AddBooksDocument, options);
      }
export type AddBooksMutationHookResult = ReturnType<typeof useAddBooksMutation>;
export type AddBooksMutationResult = Apollo.MutationResult<AddBooksMutation>;
export type AddBooksMutationOptions = Apollo.BaseMutationOptions<AddBooksMutation, AddBooksMutationVariables>;
export const AddBooksProgressDocument = gql`
    subscription addBooksProgress($id: ID!) {
  addBooks(id: $id)
}
    `;

/**
 * __useAddBooksProgressSubscription__
 *
 * To run a query within a React component, call `useAddBooksProgressSubscription` and pass it any options that fit your needs.
 * When your component renders, `useAddBooksProgressSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddBooksProgressSubscription({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useAddBooksProgressSubscription(baseOptions: Apollo.SubscriptionHookOptions<AddBooksProgressSubscription, AddBooksProgressSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<AddBooksProgressSubscription, AddBooksProgressSubscriptionVariables>(AddBooksProgressDocument, options);
      }
export type AddBooksProgressSubscriptionHookResult = ReturnType<typeof useAddBooksProgressSubscription>;
export type AddBooksProgressSubscriptionResult = Apollo.SubscriptionResult<AddBooksProgressSubscription>;
export const AddCompressBookDocument = gql`
    mutation addCompressBook($id: ID!, $file: Upload, $path: String) {
  add: addCompressBook(id: $id, file: $file, path: $path) {
    success
    code
  }
}
    `;
export type AddCompressBookMutationFn = Apollo.MutationFunction<AddCompressBookMutation, AddCompressBookMutationVariables>;

/**
 * __useAddCompressBookMutation__
 *
 * To run a mutation, you first call `useAddCompressBookMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCompressBookMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCompressBookMutation, { data, loading, error }] = useAddCompressBookMutation({
 *   variables: {
 *      id: // value for 'id'
 *      file: // value for 'file'
 *      path: // value for 'path'
 *   },
 * });
 */
export function useAddCompressBookMutation(baseOptions?: Apollo.MutationHookOptions<AddCompressBookMutation, AddCompressBookMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCompressBookMutation, AddCompressBookMutationVariables>(AddCompressBookDocument, options);
      }
export type AddCompressBookMutationHookResult = ReturnType<typeof useAddCompressBookMutation>;
export type AddCompressBookMutationResult = Apollo.MutationResult<AddCompressBookMutation>;
export type AddCompressBookMutationOptions = Apollo.BaseMutationOptions<AddCompressBookMutation, AddCompressBookMutationVariables>;
export const PluginsDocument = gql`
    query plugins {
  plugins {
    info {
      name
    }
    queries {
      add {
        name
        args
        subscription
      }
    }
  }
}
    `;

/**
 * __usePluginsQuery__
 *
 * To run a query within a React component, call `usePluginsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePluginsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePluginsQuery({
 *   variables: {
 *   },
 * });
 */
export function usePluginsQuery(baseOptions?: Apollo.QueryHookOptions<PluginsQuery, PluginsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PluginsQuery, PluginsQueryVariables>(PluginsDocument, options);
      }
export function usePluginsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PluginsQuery, PluginsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PluginsQuery, PluginsQueryVariables>(PluginsDocument, options);
        }
export type PluginsQueryHookResult = ReturnType<typeof usePluginsQuery>;
export type PluginsLazyQueryHookResult = ReturnType<typeof usePluginsLazyQuery>;
export type PluginsQueryResult = Apollo.QueryResult<PluginsQuery, PluginsQueryVariables>;
export const AddBookInfoDocument = gql`
    mutation addBookInfo($name: String!, $genres: [String!]!) {
  add: addBookInfo(name: $name, genres: $genres) {
    success
    code
  }
}
    `;
export type AddBookInfoMutationFn = Apollo.MutationFunction<AddBookInfoMutation, AddBookInfoMutationVariables>;

/**
 * __useAddBookInfoMutation__
 *
 * To run a mutation, you first call `useAddBookInfoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddBookInfoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addBookInfoMutation, { data, loading, error }] = useAddBookInfoMutation({
 *   variables: {
 *      name: // value for 'name'
 *      genres: // value for 'genres'
 *   },
 * });
 */
export function useAddBookInfoMutation(baseOptions?: Apollo.MutationHookOptions<AddBookInfoMutation, AddBookInfoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddBookInfoMutation, AddBookInfoMutationVariables>(AddBookInfoDocument, options);
      }
export type AddBookInfoMutationHookResult = ReturnType<typeof useAddBookInfoMutation>;
export type AddBookInfoMutationResult = Apollo.MutationResult<AddBookInfoMutation>;
export type AddBookInfoMutationOptions = Apollo.BaseMutationOptions<AddBookInfoMutation, AddBookInfoMutationVariables>;
export const AddBookInfoHistoriesDocument = gql`
    mutation addBookInfoHistories($histories: [BookInfoHistory!]!) {
  add: addBookInfoHistories(histories: $histories) {
    success
    code
  }
}
    `;
export type AddBookInfoHistoriesMutationFn = Apollo.MutationFunction<AddBookInfoHistoriesMutation, AddBookInfoHistoriesMutationVariables>;

/**
 * __useAddBookInfoHistoriesMutation__
 *
 * To run a mutation, you first call `useAddBookInfoHistoriesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddBookInfoHistoriesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addBookInfoHistoriesMutation, { data, loading, error }] = useAddBookInfoHistoriesMutation({
 *   variables: {
 *      histories: // value for 'histories'
 *   },
 * });
 */
export function useAddBookInfoHistoriesMutation(baseOptions?: Apollo.MutationHookOptions<AddBookInfoHistoriesMutation, AddBookInfoHistoriesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddBookInfoHistoriesMutation, AddBookInfoHistoriesMutationVariables>(AddBookInfoHistoriesDocument, options);
      }
export type AddBookInfoHistoriesMutationHookResult = ReturnType<typeof useAddBookInfoHistoriesMutation>;
export type AddBookInfoHistoriesMutationResult = Apollo.MutationResult<AddBookInfoHistoriesMutation>;
export type AddBookInfoHistoriesMutationOptions = Apollo.BaseMutationOptions<AddBookInfoHistoriesMutation, AddBookInfoHistoriesMutationVariables>;
export const DeleteUnusedFoldersDocument = gql`
    mutation deleteUnusedFolders {
  debug_deleteUnusedFolders {
    success
    code
  }
}
    `;
export type DeleteUnusedFoldersMutationFn = Apollo.MutationFunction<DeleteUnusedFoldersMutation, DeleteUnusedFoldersMutationVariables>;

/**
 * __useDeleteUnusedFoldersMutation__
 *
 * To run a mutation, you first call `useDeleteUnusedFoldersMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUnusedFoldersMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUnusedFoldersMutation, { data, loading, error }] = useDeleteUnusedFoldersMutation({
 *   variables: {
 *   },
 * });
 */
export function useDeleteUnusedFoldersMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUnusedFoldersMutation, DeleteUnusedFoldersMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteUnusedFoldersMutation, DeleteUnusedFoldersMutationVariables>(DeleteUnusedFoldersDocument, options);
      }
export type DeleteUnusedFoldersMutationHookResult = ReturnType<typeof useDeleteUnusedFoldersMutation>;
export type DeleteUnusedFoldersMutationResult = Apollo.MutationResult<DeleteUnusedFoldersMutation>;
export type DeleteUnusedFoldersMutationOptions = Apollo.BaseMutationOptions<DeleteUnusedFoldersMutation, DeleteUnusedFoldersMutationVariables>;
export const FolderSizesDocument = gql`
    query folderSizes {
  sizes: debug_folderSize {
    tmp
    cache
    book
    unusedBook
    bookInfoCount
    bookCount
  }
}
    `;

/**
 * __useFolderSizesQuery__
 *
 * To run a query within a React component, call `useFolderSizesQuery` and pass it any options that fit your needs.
 * When your component renders, `useFolderSizesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFolderSizesQuery({
 *   variables: {
 *   },
 * });
 */
export function useFolderSizesQuery(baseOptions?: Apollo.QueryHookOptions<FolderSizesQuery, FolderSizesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FolderSizesQuery, FolderSizesQueryVariables>(FolderSizesDocument, options);
      }
export function useFolderSizesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FolderSizesQuery, FolderSizesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FolderSizesQuery, FolderSizesQueryVariables>(FolderSizesDocument, options);
        }
export type FolderSizesQueryHookResult = ReturnType<typeof useFolderSizesQuery>;
export type FolderSizesLazyQueryHookResult = ReturnType<typeof useFolderSizesLazyQuery>;
export type FolderSizesQueryResult = Apollo.QueryResult<FolderSizesQuery, FolderSizesQueryVariables>;
export const DeleteBookInfoDocument = gql`
    mutation deleteBookInfo($id: ID!) {
  del: deleteBookInfo(id: $id) {
    success
    code
    books {
      id
      pages
    }
  }
}
    `;
export type DeleteBookInfoMutationFn = Apollo.MutationFunction<DeleteBookInfoMutation, DeleteBookInfoMutationVariables>;

/**
 * __useDeleteBookInfoMutation__
 *
 * To run a mutation, you first call `useDeleteBookInfoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteBookInfoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteBookInfoMutation, { data, loading, error }] = useDeleteBookInfoMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteBookInfoMutation(baseOptions?: Apollo.MutationHookOptions<DeleteBookInfoMutation, DeleteBookInfoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteBookInfoMutation, DeleteBookInfoMutationVariables>(DeleteBookInfoDocument, options);
      }
export type DeleteBookInfoMutationHookResult = ReturnType<typeof useDeleteBookInfoMutation>;
export type DeleteBookInfoMutationResult = Apollo.MutationResult<DeleteBookInfoMutation>;
export type DeleteBookInfoMutationOptions = Apollo.BaseMutationOptions<DeleteBookInfoMutation, DeleteBookInfoMutationVariables>;
export const EditBookInfoDocument = gql`
    mutation editBookInfo($id: ID!, $name: String, $genres: [String!]!) {
  edit: editBookInfo(id: $id, name: $name, genres: $genres) {
    success
    code
  }
}
    `;
export type EditBookInfoMutationFn = Apollo.MutationFunction<EditBookInfoMutation, EditBookInfoMutationVariables>;

/**
 * __useEditBookInfoMutation__
 *
 * To run a mutation, you first call `useEditBookInfoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditBookInfoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editBookInfoMutation, { data, loading, error }] = useEditBookInfoMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      genres: // value for 'genres'
 *   },
 * });
 */
export function useEditBookInfoMutation(baseOptions?: Apollo.MutationHookOptions<EditBookInfoMutation, EditBookInfoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditBookInfoMutation, EditBookInfoMutationVariables>(EditBookInfoDocument, options);
      }
export type EditBookInfoMutationHookResult = ReturnType<typeof useEditBookInfoMutation>;
export type EditBookInfoMutationResult = Apollo.MutationResult<EditBookInfoMutation>;
export type EditBookInfoMutationOptions = Apollo.BaseMutationOptions<EditBookInfoMutation, EditBookInfoMutationVariables>;
export const EditBookDocument = gql`
    mutation editBook($id: ID!, $number: String) {
  edit: editBook(id: $id, number: $number) {
    success
    code
  }
}
    `;
export type EditBookMutationFn = Apollo.MutationFunction<EditBookMutation, EditBookMutationVariables>;

/**
 * __useEditBookMutation__
 *
 * To run a mutation, you first call `useEditBookMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditBookMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editBookMutation, { data, loading, error }] = useEditBookMutation({
 *   variables: {
 *      id: // value for 'id'
 *      number: // value for 'number'
 *   },
 * });
 */
export function useEditBookMutation(baseOptions?: Apollo.MutationHookOptions<EditBookMutation, EditBookMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditBookMutation, EditBookMutationVariables>(EditBookDocument, options);
      }
export type EditBookMutationHookResult = ReturnType<typeof useEditBookMutation>;
export type EditBookMutationResult = Apollo.MutationResult<EditBookMutation>;
export type EditBookMutationOptions = Apollo.BaseMutationOptions<EditBookMutation, EditBookMutationVariables>;
export const DownloadBookInfosDocument = gql`
    query downloadBookInfos($id: ID!) {
  bookInfo(id: $id) {
    id
    name
    count
    books {
      id
      number
      pages
    }
  }
}
    `;

/**
 * __useDownloadBookInfosQuery__
 *
 * To run a query within a React component, call `useDownloadBookInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useDownloadBookInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDownloadBookInfosQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDownloadBookInfosQuery(baseOptions: Apollo.QueryHookOptions<DownloadBookInfosQuery, DownloadBookInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DownloadBookInfosQuery, DownloadBookInfosQueryVariables>(DownloadBookInfosDocument, options);
      }
export function useDownloadBookInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DownloadBookInfosQuery, DownloadBookInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DownloadBookInfosQuery, DownloadBookInfosQueryVariables>(DownloadBookInfosDocument, options);
        }
export type DownloadBookInfosQueryHookResult = ReturnType<typeof useDownloadBookInfosQuery>;
export type DownloadBookInfosLazyQueryHookResult = ReturnType<typeof useDownloadBookInfosLazyQuery>;
export type DownloadBookInfosQueryResult = Apollo.QueryResult<DownloadBookInfosQuery, DownloadBookInfosQueryVariables>;
export const BulkEditPagesDocument = gql`
    mutation bulkEditPages($bookId: ID!, $editActions: [EditAction!]!) {
  bulkEditPage(id: $bookId, actions: $editActions) {
    success
    code
    message
  }
}
    `;
export type BulkEditPagesMutationFn = Apollo.MutationFunction<BulkEditPagesMutation, BulkEditPagesMutationVariables>;

/**
 * __useBulkEditPagesMutation__
 *
 * To run a mutation, you first call `useBulkEditPagesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBulkEditPagesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [bulkEditPagesMutation, { data, loading, error }] = useBulkEditPagesMutation({
 *   variables: {
 *      bookId: // value for 'bookId'
 *      editActions: // value for 'editActions'
 *   },
 * });
 */
export function useBulkEditPagesMutation(baseOptions?: Apollo.MutationHookOptions<BulkEditPagesMutation, BulkEditPagesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<BulkEditPagesMutation, BulkEditPagesMutationVariables>(BulkEditPagesDocument, options);
      }
export type BulkEditPagesMutationHookResult = ReturnType<typeof useBulkEditPagesMutation>;
export type BulkEditPagesMutationResult = Apollo.MutationResult<BulkEditPagesMutation>;
export type BulkEditPagesMutationOptions = Apollo.BaseMutationOptions<BulkEditPagesMutation, BulkEditPagesMutationVariables>;
export const BookDocument = gql`
    query book($id: ID!) {
  book(id: $id) {
    id
    number
    pages
    info {
      id
      name
    }
  }
}
    `;

/**
 * __useBookQuery__
 *
 * To run a query within a React component, call `useBookQuery` and pass it any options that fit your needs.
 * When your component renders, `useBookQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBookQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useBookQuery(baseOptions: Apollo.QueryHookOptions<BookQuery, BookQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BookQuery, BookQueryVariables>(BookDocument, options);
      }
export function useBookLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BookQuery, BookQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BookQuery, BookQueryVariables>(BookDocument, options);
        }
export type BookQueryHookResult = ReturnType<typeof useBookQuery>;
export type BookLazyQueryHookResult = ReturnType<typeof useBookLazyQuery>;
export type BookQueryResult = Apollo.QueryResult<BookQuery, BookQueryVariables>;
export const RelayBookInfosDocument = gql`
    query relayBookInfos($first: Int, $after: String, $option: BookInfosOption!) {
  bookInfos: relayBookInfos(first: $first, after: $after, option: $option) @connection(key: "relayBookInfos", filter: ["option"]) {
    edges {
      cursor
      node {
        id
        name
        count
        thumbnail {
          bookId
          pageIndex
          bookPageCount
        }
        history
        genres {
          name
          invisible
        }
        updatedAt
      }
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
  }
}
    `;

/**
 * __useRelayBookInfosQuery__
 *
 * To run a query within a React component, call `useRelayBookInfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useRelayBookInfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRelayBookInfosQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      option: // value for 'option'
 *   },
 * });
 */
export function useRelayBookInfosQuery(baseOptions: Apollo.QueryHookOptions<RelayBookInfosQuery, RelayBookInfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RelayBookInfosQuery, RelayBookInfosQueryVariables>(RelayBookInfosDocument, options);
      }
export function useRelayBookInfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RelayBookInfosQuery, RelayBookInfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RelayBookInfosQuery, RelayBookInfosQueryVariables>(RelayBookInfosDocument, options);
        }
export type RelayBookInfosQueryHookResult = ReturnType<typeof useRelayBookInfosQuery>;
export type RelayBookInfosLazyQueryHookResult = ReturnType<typeof useRelayBookInfosLazyQuery>;
export type RelayBookInfosQueryResult = Apollo.QueryResult<RelayBookInfosQuery, RelayBookInfosQueryVariables>;
export const DeleteGenreDocument = gql`
    mutation DeleteGenre($name: String!) {
  deleteGenre(genre: $name) {
    code
    success
    message
  }
}
    `;
export type DeleteGenreMutationFn = Apollo.MutationFunction<DeleteGenreMutation, DeleteGenreMutationVariables>;

/**
 * __useDeleteGenreMutation__
 *
 * To run a mutation, you first call `useDeleteGenreMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteGenreMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteGenreMutation, { data, loading, error }] = useDeleteGenreMutation({
 *   variables: {
 *      name: // value for 'name'
 *   },
 * });
 */
export function useDeleteGenreMutation(baseOptions?: Apollo.MutationHookOptions<DeleteGenreMutation, DeleteGenreMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteGenreMutation, DeleteGenreMutationVariables>(DeleteGenreDocument, options);
      }
export type DeleteGenreMutationHookResult = ReturnType<typeof useDeleteGenreMutation>;
export type DeleteGenreMutationResult = Apollo.MutationResult<DeleteGenreMutation>;
export type DeleteGenreMutationOptions = Apollo.BaseMutationOptions<DeleteGenreMutation, DeleteGenreMutationVariables>;
export const EditGenreDocument = gql`
    mutation EditGenre($oldName: String!, $newName: String, $invisible: Boolean) {
  editGenre(oldName: $oldName, newName: $newName, invisible: $invisible) {
    code
    success
    message
  }
}
    `;
export type EditGenreMutationFn = Apollo.MutationFunction<EditGenreMutation, EditGenreMutationVariables>;

/**
 * __useEditGenreMutation__
 *
 * To run a mutation, you first call `useEditGenreMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditGenreMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editGenreMutation, { data, loading, error }] = useEditGenreMutation({
 *   variables: {
 *      oldName: // value for 'oldName'
 *      newName: // value for 'newName'
 *      invisible: // value for 'invisible'
 *   },
 * });
 */
export function useEditGenreMutation(baseOptions?: Apollo.MutationHookOptions<EditGenreMutation, EditGenreMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditGenreMutation, EditGenreMutationVariables>(EditGenreDocument, options);
      }
export type EditGenreMutationHookResult = ReturnType<typeof useEditGenreMutation>;
export type EditGenreMutationResult = Apollo.MutationResult<EditGenreMutation>;
export type EditGenreMutationOptions = Apollo.BaseMutationOptions<EditGenreMutation, EditGenreMutationVariables>;
export const DeleteBooksDocument = gql`
    mutation deleteBooks($infoId: ID!, $ids: [ID!]!) {
  deleteBooks(infoId: $infoId, ids: $ids) {
    success
    code
  }
}
    `;
export type DeleteBooksMutationFn = Apollo.MutationFunction<DeleteBooksMutation, DeleteBooksMutationVariables>;

/**
 * __useDeleteBooksMutation__
 *
 * To run a mutation, you first call `useDeleteBooksMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteBooksMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteBooksMutation, { data, loading, error }] = useDeleteBooksMutation({
 *   variables: {
 *      infoId: // value for 'infoId'
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useDeleteBooksMutation(baseOptions?: Apollo.MutationHookOptions<DeleteBooksMutation, DeleteBooksMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteBooksMutation, DeleteBooksMutationVariables>(DeleteBooksDocument, options);
      }
export type DeleteBooksMutationHookResult = ReturnType<typeof useDeleteBooksMutation>;
export type DeleteBooksMutationResult = Apollo.MutationResult<DeleteBooksMutation>;
export type DeleteBooksMutationOptions = Apollo.BaseMutationOptions<DeleteBooksMutation, DeleteBooksMutationVariables>;
export const MoveBooksDocument = gql`
    mutation moveBooks($infoId: ID!, $ids: [ID!]!) {
  moveBooks(infoId: $infoId, ids: $ids) {
    success
    code
  }
}
    `;
export type MoveBooksMutationFn = Apollo.MutationFunction<MoveBooksMutation, MoveBooksMutationVariables>;

/**
 * __useMoveBooksMutation__
 *
 * To run a mutation, you first call `useMoveBooksMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMoveBooksMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [moveBooksMutation, { data, loading, error }] = useMoveBooksMutation({
 *   variables: {
 *      infoId: // value for 'infoId'
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useMoveBooksMutation(baseOptions?: Apollo.MutationHookOptions<MoveBooksMutation, MoveBooksMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<MoveBooksMutation, MoveBooksMutationVariables>(MoveBooksDocument, options);
      }
export type MoveBooksMutationHookResult = ReturnType<typeof useMoveBooksMutation>;
export type MoveBooksMutationResult = Apollo.MutationResult<MoveBooksMutation>;
export type MoveBooksMutationOptions = Apollo.BaseMutationOptions<MoveBooksMutation, MoveBooksMutationVariables>;
export const EditBookInfoThumbnailDocument = gql`
    mutation editBookInfoThumbnail($id: ID!, $thumbnail: ID) {
  edit: editBookInfo(id: $id, thumbnail: $thumbnail) {
    success
    code
  }
}
    `;
export type EditBookInfoThumbnailMutationFn = Apollo.MutationFunction<EditBookInfoThumbnailMutation, EditBookInfoThumbnailMutationVariables>;

/**
 * __useEditBookInfoThumbnailMutation__
 *
 * To run a mutation, you first call `useEditBookInfoThumbnailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditBookInfoThumbnailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editBookInfoThumbnailMutation, { data, loading, error }] = useEditBookInfoThumbnailMutation({
 *   variables: {
 *      id: // value for 'id'
 *      thumbnail: // value for 'thumbnail'
 *   },
 * });
 */
export function useEditBookInfoThumbnailMutation(baseOptions?: Apollo.MutationHookOptions<EditBookInfoThumbnailMutation, EditBookInfoThumbnailMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditBookInfoThumbnailMutation, EditBookInfoThumbnailMutationVariables>(EditBookInfoThumbnailDocument, options);
      }
export type EditBookInfoThumbnailMutationHookResult = ReturnType<typeof useEditBookInfoThumbnailMutation>;
export type EditBookInfoThumbnailMutationResult = Apollo.MutationResult<EditBookInfoThumbnailMutation>;
export type EditBookInfoThumbnailMutationOptions = Apollo.BaseMutationOptions<EditBookInfoThumbnailMutation, EditBookInfoThumbnailMutationVariables>;
export const BookPagesDocument = gql`
    query bookPages($id: ID!) {
  book(id: $id) {
    id
    pages
  }
}
    `;

/**
 * __useBookPagesQuery__
 *
 * To run a query within a React component, call `useBookPagesQuery` and pass it any options that fit your needs.
 * When your component renders, `useBookPagesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBookPagesQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useBookPagesQuery(baseOptions: Apollo.QueryHookOptions<BookPagesQuery, BookPagesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BookPagesQuery, BookPagesQueryVariables>(BookPagesDocument, options);
      }
export function useBookPagesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BookPagesQuery, BookPagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BookPagesQuery, BookPagesQueryVariables>(BookPagesDocument, options);
        }
export type BookPagesQueryHookResult = ReturnType<typeof useBookPagesQuery>;
export type BookPagesLazyQueryHookResult = ReturnType<typeof useBookPagesLazyQuery>;
export type BookPagesQueryResult = Apollo.QueryResult<BookPagesQuery, BookPagesQueryVariables>;
export const EditBookThumbnailDocument = gql`
    mutation editBookThumbnail($id: ID!, $th: Int) {
  edit: editBook(id: $id, thumbnail: $th) {
    success
    code
  }
}
    `;
export type EditBookThumbnailMutationFn = Apollo.MutationFunction<EditBookThumbnailMutation, EditBookThumbnailMutationVariables>;

/**
 * __useEditBookThumbnailMutation__
 *
 * To run a mutation, you first call `useEditBookThumbnailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditBookThumbnailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editBookThumbnailMutation, { data, loading, error }] = useEditBookThumbnailMutation({
 *   variables: {
 *      id: // value for 'id'
 *      th: // value for 'th'
 *   },
 * });
 */
export function useEditBookThumbnailMutation(baseOptions?: Apollo.MutationHookOptions<EditBookThumbnailMutation, EditBookThumbnailMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditBookThumbnailMutation, EditBookThumbnailMutationVariables>(EditBookThumbnailDocument, options);
      }
export type EditBookThumbnailMutationHookResult = ReturnType<typeof useEditBookThumbnailMutation>;
export type EditBookThumbnailMutationResult = Apollo.MutationResult<EditBookThumbnailMutation>;
export type EditBookThumbnailMutationOptions = Apollo.BaseMutationOptions<EditBookThumbnailMutation, EditBookThumbnailMutationVariables>;
export const BookInfoDocument = gql`
    query bookInfo($id: ID!, $order: BookOrder) {
  bookInfo(id: $id) {
    id
    name
    books(order: $order) {
      id
      number
      pages
      thumbnail
      updatedAt
      info {
        id
      }
    }
  }
}
    `;

/**
 * __useBookInfoQuery__
 *
 * To run a query within a React component, call `useBookInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useBookInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBookInfoQuery({
 *   variables: {
 *      id: // value for 'id'
 *      order: // value for 'order'
 *   },
 * });
 */
export function useBookInfoQuery(baseOptions: Apollo.QueryHookOptions<BookInfoQuery, BookInfoQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BookInfoQuery, BookInfoQueryVariables>(BookInfoDocument, options);
      }
export function useBookInfoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BookInfoQuery, BookInfoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BookInfoQuery, BookInfoQueryVariables>(BookInfoDocument, options);
        }
export type BookInfoQueryHookResult = ReturnType<typeof useBookInfoQuery>;
export type BookInfoLazyQueryHookResult = ReturnType<typeof useBookInfoLazyQuery>;
export type BookInfoQueryResult = Apollo.QueryResult<BookInfoQuery, BookInfoQueryVariables>;
export const GenresDocument = gql`
    query genres {
  genres {
    name
    invisible
  }
}
    `;

/**
 * __useGenresQuery__
 *
 * To run a query within a React component, call `useGenresQuery` and pass it any options that fit your needs.
 * When your component renders, `useGenresQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGenresQuery({
 *   variables: {
 *   },
 * });
 */
export function useGenresQuery(baseOptions?: Apollo.QueryHookOptions<GenresQuery, GenresQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GenresQuery, GenresQueryVariables>(GenresDocument, options);
      }
export function useGenresLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GenresQuery, GenresQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GenresQuery, GenresQueryVariables>(GenresDocument, options);
        }
export type GenresQueryHookResult = ReturnType<typeof useGenresQuery>;
export type GenresLazyQueryHookResult = ReturnType<typeof useGenresLazyQuery>;
export type GenresQueryResult = Apollo.QueryResult<GenresQuery, GenresQueryVariables>;