/* This file generated by @graphql-codegen */
/* eslint-disable */
import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import { BookInfo as BookInfoModel } from '../src/database/models/BookInfo';
import { Book as BookModel } from '../src/database/models/Book';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };
export type BigInt = number;
export type IntRange = (number | [number, number])[];
export type Upload = Promise<{ filename: string, mimetype: string, encoding: string, createReadStream: () => NodeJS.ReadableStream }>;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  BigInt: BigInt;
  IntRange: IntRange;
  Upload: Upload;
};

export type AddBookInfoResult = {
  __typename?: 'AddBookInfoResult';
  bookInfo?: Maybe<BookInfo>;
  code?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  success: Scalars['Boolean'];
};

export type Auth0 = {
  __typename?: 'Auth0';
  clientId: Scalars['String'];
  domain: Scalars['String'];
};

export type Book = {
  __typename?: 'Book';
  id: Scalars['ID'];
  info?: Maybe<BookInfo>;
  number: Scalars['String'];
  pages: Scalars['Int'];
  thumbnail?: Maybe<Scalars['Int']>;
  updatedAt: Scalars['String'];
};

export type BookInfo = {
  __typename?: 'BookInfo';
  books: Array<Book>;
  count: Scalars['Int'];
  genres: Array<Genre>;
  id: Scalars['ID'];
  name: Scalars['String'];
  thumbnail?: Maybe<BookInfoThumbnail>;
  updatedAt: Scalars['String'];
};


export type BookInfoBooksArgs = {
  order?: InputMaybe<BookOrder>;
};

export type BookInfoEdge = {
  __typename?: 'BookInfoEdge';
  cursor: Scalars['String'];
  node: BookInfo;
};

export type BookInfoList = {
  __typename?: 'BookInfoList';
  hasNext: Scalars['Boolean'];
  infos: Array<BookInfo>;
};

export const BookInfoOrder = {
  AddNewest: 'Add_Newest',
  AddOldest: 'Add_Oldest',
  NameAsc: 'Name_Asc',
  NameDesc: 'Name_Desc',
  UpdateNewest: 'Update_Newest',
  UpdateOldest: 'Update_Oldest'
} as const;

export type BookInfoOrder = typeof BookInfoOrder[keyof typeof BookInfoOrder];
export type BookInfoPartialList = {
  __typename?: 'BookInfoPartialList';
  edges: Array<BookInfoEdge>;
  pageInfo: PageInfo;
};

export type BookInfoThumbnail = {
  __typename?: 'BookInfoThumbnail';
  bookId: Scalars['ID'];
  bookPageCount: Scalars['Int'];
  pageIndex: Scalars['Int'];
};

export type BookInfosOption = {
  genres?: InputMaybe<Array<Scalars['String']>>;
  order?: InputMaybe<BookInfoOrder>;
  search?: InputMaybe<Scalars['String']>;
  searchMode?: InputMaybe<SearchMode>;
};

export const BookOrder = {
  NumberAsc: 'Number_Asc',
  NumberDesc: 'Number_Desc',
  UpdateNewest: 'Update_Newest',
  UpdateOldest: 'Update_Oldest'
} as const;

export type BookOrder = typeof BookOrder[keyof typeof BookOrder];
export type CropEditAction = {
  bottom?: InputMaybe<Scalars['Int']>;
  left?: InputMaybe<Scalars['Int']>;
  pageRange: Scalars['IntRange'];
  right?: InputMaybe<Scalars['Int']>;
  top?: InputMaybe<Scalars['Int']>;
};

export type Debug_BookCounts = {
  __typename?: 'Debug_BookCounts';
  bookCount: Scalars['Int'];
  bookInfoCount: Scalars['Int'];
};

export type DeleteBookInfoResult = {
  __typename?: 'DeleteBookInfoResult';
  books: Array<Book>;
  code?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  success: Scalars['Boolean'];
};

export type DeleteEditAction = {
  pageRange: Scalars['IntRange'];
};

export type EditAction = {
  crop?: InputMaybe<CropEditAction>;
  delete?: InputMaybe<DeleteEditAction>;
  editType: EditType;
  hstack?: InputMaybe<HStackEditAction>;
  put?: InputMaybe<UploadEditAction>;
  replace?: InputMaybe<UploadEditAction>;
  split?: InputMaybe<SplitEditAction>;
};

export type EditBookInfoResult = {
  __typename?: 'EditBookInfoResult';
  bookInfo?: Maybe<BookInfo>;
  code?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  success: Scalars['Boolean'];
};

export const EditType = {
  Crop: 'Crop',
  Delete: 'Delete',
  HStack: 'HStack',
  Put: 'Put',
  Replace: 'Replace',
  Split: 'Split'
} as const;

export type EditType = typeof EditType[keyof typeof EditType];
export type Genre = {
  __typename?: 'Genre';
  invisible: Scalars['Boolean'];
  name: Scalars['ID'];
};

export type HStackEditAction = {
  pageRange: Scalars['IntRange'];
};

export type InputBook = {
  file?: InputMaybe<Scalars['Upload']>;
  number: Scalars['String'];
  path?: InputMaybe<Scalars['String']>;
};

export type InputRead = {
  bookId: Scalars['ID'];
  infoId: Scalars['ID'];
  page: Scalars['Int'];
  updatedAt: Scalars['String'];
};

export type Mutation = {
  __typename?: 'Mutation';
  addBookInfo: AddBookInfoResult;
  addBooks: Array<Result>;
  addCompressBook: ResultWithBookResults;
  bulkEditPage: Result;
  debug_deleteUnusedFolders: Result;
  debug_rebuildMeiliSearch: Result;
  deleteBookInfo: DeleteBookInfoResult;
  deleteBooks: Result;
  deleteGenre: Result;
  editBook: Result;
  editBookInfo: EditBookInfoResult;
  editGenre: Result;
  moveBooks: Result;
};


export type MutationAddBookInfoArgs = {
  genres?: InputMaybe<Array<Scalars['String']>>;
  name: Scalars['String'];
};


export type MutationAddBooksArgs = {
  books: Array<InputBook>;
  id: Scalars['ID'];
};


export type MutationAddCompressBookArgs = {
  file?: InputMaybe<Scalars['Upload']>;
  id: Scalars['ID'];
  path?: InputMaybe<Scalars['String']>;
};


export type MutationBulkEditPageArgs = {
  actions: Array<EditAction>;
  id: Scalars['ID'];
};


export type MutationDeleteBookInfoArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteBooksArgs = {
  ids: Array<Scalars['ID']>;
  infoId: Scalars['ID'];
};


export type MutationDeleteGenreArgs = {
  genre: Scalars['String'];
};


export type MutationEditBookArgs = {
  id: Scalars['ID'];
  number?: InputMaybe<Scalars['String']>;
  thumbnail?: InputMaybe<Scalars['Int']>;
};


export type MutationEditBookInfoArgs = {
  genres?: InputMaybe<Array<Scalars['String']>>;
  id: Scalars['ID'];
  name?: InputMaybe<Scalars['String']>;
  thumbnail?: InputMaybe<Scalars['ID']>;
};


export type MutationEditGenreArgs = {
  invisible?: InputMaybe<Scalars['Boolean']>;
  newName?: InputMaybe<Scalars['String']>;
  oldName: Scalars['String'];
};


export type MutationMoveBooksArgs = {
  ids: Array<Scalars['ID']>;
  infoId: Scalars['ID'];
};

export type PageInfo = {
  __typename?: 'PageInfo';
  endCursor: Scalars['String'];
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor: Scalars['String'];
};

export type Query = {
  __typename?: 'Query';
  availableSearchModes: Array<SearchMode>;
  book?: Maybe<Book>;
  bookInfo?: Maybe<BookInfo>;
  bookInfos: Array<Maybe<BookInfo>>;
  books: Array<Maybe<Book>>;
  debug_bookCounts: Debug_BookCounts;
  genres: Array<Genre>;
  relayBookInfos: BookInfoPartialList;
};


export type QueryBookArgs = {
  id: Scalars['ID'];
};


export type QueryBookInfoArgs = {
  id: Scalars['ID'];
};


export type QueryBookInfosArgs = {
  ids: Array<Scalars['ID']>;
};


export type QueryBooksArgs = {
  ids: Array<Scalars['ID']>;
};


export type QueryRelayBookInfosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  option?: InputMaybe<BookInfosOption>;
};

export type Read = {
  __typename?: 'Read';
  bookId: Scalars['ID'];
  infoId: Scalars['ID'];
  page: Scalars['Int'];
  updatedAt: Scalars['String'];
};

export type ReadList = {
  __typename?: 'ReadList';
  latestRevision: Revision;
  readList: Array<Read>;
};

export type Result = {
  __typename?: 'Result';
  code?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  success: Scalars['Boolean'];
};

export type ResultWithBookResults = {
  __typename?: 'ResultWithBookResults';
  bookResults?: Maybe<Array<Result>>;
  code?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  success: Scalars['Boolean'];
};

export type Revision = {
  __typename?: 'Revision';
  count: Scalars['Int'];
  syncedAt: Scalars['String'];
};

export const SearchMode = {
  Database: 'DATABASE',
  Elasticsearch: 'ELASTICSEARCH',
  Meilisearch: 'MEILISEARCH'
} as const;

export type SearchMode = typeof SearchMode[keyof typeof SearchMode];
export type SplitEditAction = {
  pageRange: Scalars['IntRange'];
  splitCount?: InputMaybe<Scalars['Int']>;
  splitType: SplitType;
};

export const SplitType = {
  Horizontal: 'HORIZONTAL',
  Vertical: 'VERTICAL'
} as const;

export type SplitType = typeof SplitType[keyof typeof SplitType];
export type Subscription = {
  __typename?: 'Subscription';
  addBooks: Scalars['String'];
  bulkEditPage: Scalars['String'];
};


export type SubscriptionAddBooksArgs = {
  id: Scalars['ID'];
};


export type SubscriptionBulkEditPageArgs = {
  id: Scalars['ID'];
};

export type UploadEditAction = {
  image: Scalars['Upload'];
  pageIndex: Scalars['Int'];
};



export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  AddBookInfoResult: ResolverTypeWrapper<Omit<AddBookInfoResult, 'bookInfo'> & { bookInfo?: Maybe<ResolversTypes['BookInfo']> }>;
  Auth0: ResolverTypeWrapper<Auth0>;
  BigInt: ResolverTypeWrapper<Scalars['BigInt']>;
  Book: ResolverTypeWrapper<BookModel>;
  BookInfo: ResolverTypeWrapper<BookInfoModel>;
  BookInfoEdge: ResolverTypeWrapper<Omit<BookInfoEdge, 'node'> & { node: ResolversTypes['BookInfo'] }>;
  BookInfoList: ResolverTypeWrapper<Omit<BookInfoList, 'infos'> & { infos: Array<ResolversTypes['BookInfo']> }>;
  BookInfoOrder: BookInfoOrder;
  BookInfoPartialList: ResolverTypeWrapper<Omit<BookInfoPartialList, 'edges'> & { edges: Array<ResolversTypes['BookInfoEdge']> }>;
  BookInfoThumbnail: ResolverTypeWrapper<BookInfoThumbnail>;
  BookInfosOption: BookInfosOption;
  BookOrder: BookOrder;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  CropEditAction: CropEditAction;
  Debug_BookCounts: ResolverTypeWrapper<Debug_BookCounts>;
  DeleteBookInfoResult: ResolverTypeWrapper<Omit<DeleteBookInfoResult, 'books'> & { books: Array<ResolversTypes['Book']> }>;
  DeleteEditAction: DeleteEditAction;
  EditAction: EditAction;
  EditBookInfoResult: ResolverTypeWrapper<Omit<EditBookInfoResult, 'bookInfo'> & { bookInfo?: Maybe<ResolversTypes['BookInfo']> }>;
  EditType: EditType;
  Genre: ResolverTypeWrapper<Genre>;
  HStackEditAction: HStackEditAction;
  ID: ResolverTypeWrapper<Scalars['ID']>;
  InputBook: InputBook;
  InputRead: InputRead;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  IntRange: ResolverTypeWrapper<Scalars['IntRange']>;
  Mutation: ResolverTypeWrapper<{}>;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  Query: ResolverTypeWrapper<{}>;
  Read: ResolverTypeWrapper<Read>;
  ReadList: ResolverTypeWrapper<ReadList>;
  Result: ResolverTypeWrapper<Result>;
  ResultWithBookResults: ResolverTypeWrapper<ResultWithBookResults>;
  Revision: ResolverTypeWrapper<Revision>;
  SearchMode: SearchMode;
  SplitEditAction: SplitEditAction;
  SplitType: SplitType;
  String: ResolverTypeWrapper<Scalars['String']>;
  Subscription: ResolverTypeWrapper<{}>;
  Upload: ResolverTypeWrapper<Scalars['Upload']>;
  UploadEditAction: UploadEditAction;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  AddBookInfoResult: Omit<AddBookInfoResult, 'bookInfo'> & { bookInfo?: Maybe<ResolversParentTypes['BookInfo']> };
  Auth0: Auth0;
  BigInt: Scalars['BigInt'];
  Book: BookModel;
  BookInfo: BookInfoModel;
  BookInfoEdge: Omit<BookInfoEdge, 'node'> & { node: ResolversParentTypes['BookInfo'] };
  BookInfoList: Omit<BookInfoList, 'infos'> & { infos: Array<ResolversParentTypes['BookInfo']> };
  BookInfoPartialList: Omit<BookInfoPartialList, 'edges'> & { edges: Array<ResolversParentTypes['BookInfoEdge']> };
  BookInfoThumbnail: BookInfoThumbnail;
  BookInfosOption: BookInfosOption;
  Boolean: Scalars['Boolean'];
  CropEditAction: CropEditAction;
  Debug_BookCounts: Debug_BookCounts;
  DeleteBookInfoResult: Omit<DeleteBookInfoResult, 'books'> & { books: Array<ResolversParentTypes['Book']> };
  DeleteEditAction: DeleteEditAction;
  EditAction: EditAction;
  EditBookInfoResult: Omit<EditBookInfoResult, 'bookInfo'> & { bookInfo?: Maybe<ResolversParentTypes['BookInfo']> };
  Genre: Genre;
  HStackEditAction: HStackEditAction;
  ID: Scalars['ID'];
  InputBook: InputBook;
  InputRead: InputRead;
  Int: Scalars['Int'];
  IntRange: Scalars['IntRange'];
  Mutation: {};
  PageInfo: PageInfo;
  Query: {};
  Read: Read;
  ReadList: ReadList;
  Result: Result;
  ResultWithBookResults: ResultWithBookResults;
  Revision: Revision;
  SplitEditAction: SplitEditAction;
  String: Scalars['String'];
  Subscription: {};
  Upload: Scalars['Upload'];
  UploadEditAction: UploadEditAction;
};

export type AddBookInfoResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddBookInfoResult'] = ResolversParentTypes['AddBookInfoResult']> = {
  bookInfo?: Resolver<Maybe<ResolversTypes['BookInfo']>, ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Auth0Resolvers<ContextType = any, ParentType extends ResolversParentTypes['Auth0'] = ResolversParentTypes['Auth0']> = {
  clientId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  domain?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {
  name: 'BigInt';
}

export type BookResolvers<ContextType = any, ParentType extends ResolversParentTypes['Book'] = ResolversParentTypes['Book']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  info?: Resolver<Maybe<ResolversTypes['BookInfo']>, ParentType, ContextType>;
  number?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pages?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  thumbnail?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BookInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['BookInfo'] = ResolversParentTypes['BookInfo']> = {
  books?: Resolver<Array<ResolversTypes['Book']>, ParentType, ContextType, RequireFields<BookInfoBooksArgs, 'order'>>;
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  genres?: Resolver<Array<ResolversTypes['Genre']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  thumbnail?: Resolver<Maybe<ResolversTypes['BookInfoThumbnail']>, ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BookInfoEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['BookInfoEdge'] = ResolversParentTypes['BookInfoEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['BookInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BookInfoListResolvers<ContextType = any, ParentType extends ResolversParentTypes['BookInfoList'] = ResolversParentTypes['BookInfoList']> = {
  hasNext?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  infos?: Resolver<Array<ResolversTypes['BookInfo']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BookInfoPartialListResolvers<ContextType = any, ParentType extends ResolversParentTypes['BookInfoPartialList'] = ResolversParentTypes['BookInfoPartialList']> = {
  edges?: Resolver<Array<ResolversTypes['BookInfoEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BookInfoThumbnailResolvers<ContextType = any, ParentType extends ResolversParentTypes['BookInfoThumbnail'] = ResolversParentTypes['BookInfoThumbnail']> = {
  bookId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  bookPageCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  pageIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Debug_BookCountsResolvers<ContextType = any, ParentType extends ResolversParentTypes['Debug_BookCounts'] = ResolversParentTypes['Debug_BookCounts']> = {
  bookCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  bookInfoCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteBookInfoResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteBookInfoResult'] = ResolversParentTypes['DeleteBookInfoResult']> = {
  books?: Resolver<Array<ResolversTypes['Book']>, ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EditBookInfoResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['EditBookInfoResult'] = ResolversParentTypes['EditBookInfoResult']> = {
  bookInfo?: Resolver<Maybe<ResolversTypes['BookInfo']>, ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GenreResolvers<ContextType = any, ParentType extends ResolversParentTypes['Genre'] = ResolversParentTypes['Genre']> = {
  invisible?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface IntRangeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['IntRange'], any> {
  name: 'IntRange';
}

export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {
  addBookInfo?: Resolver<ResolversTypes['AddBookInfoResult'], ParentType, ContextType, RequireFields<MutationAddBookInfoArgs, 'name'>>;
  addBooks?: Resolver<Array<ResolversTypes['Result']>, ParentType, ContextType, RequireFields<MutationAddBooksArgs, 'books' | 'id'>>;
  addCompressBook?: Resolver<ResolversTypes['ResultWithBookResults'], ParentType, ContextType, RequireFields<MutationAddCompressBookArgs, 'id'>>;
  bulkEditPage?: Resolver<ResolversTypes['Result'], ParentType, ContextType, RequireFields<MutationBulkEditPageArgs, 'actions' | 'id'>>;
  debug_deleteUnusedFolders?: Resolver<ResolversTypes['Result'], ParentType, ContextType>;
  debug_rebuildMeiliSearch?: Resolver<ResolversTypes['Result'], ParentType, ContextType>;
  deleteBookInfo?: Resolver<ResolversTypes['DeleteBookInfoResult'], ParentType, ContextType, RequireFields<MutationDeleteBookInfoArgs, 'id'>>;
  deleteBooks?: Resolver<ResolversTypes['Result'], ParentType, ContextType, RequireFields<MutationDeleteBooksArgs, 'ids' | 'infoId'>>;
  deleteGenre?: Resolver<ResolversTypes['Result'], ParentType, ContextType, RequireFields<MutationDeleteGenreArgs, 'genre'>>;
  editBook?: Resolver<ResolversTypes['Result'], ParentType, ContextType, RequireFields<MutationEditBookArgs, 'id'>>;
  editBookInfo?: Resolver<ResolversTypes['EditBookInfoResult'], ParentType, ContextType, RequireFields<MutationEditBookInfoArgs, 'id'>>;
  editGenre?: Resolver<ResolversTypes['Result'], ParentType, ContextType, RequireFields<MutationEditGenreArgs, 'oldName'>>;
  moveBooks?: Resolver<ResolversTypes['Result'], ParentType, ContextType, RequireFields<MutationMoveBooksArgs, 'ids' | 'infoId'>>;
};

export type PageInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = {
  endCursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
  availableSearchModes?: Resolver<Array<ResolversTypes['SearchMode']>, ParentType, ContextType>;
  book?: Resolver<Maybe<ResolversTypes['Book']>, ParentType, ContextType, RequireFields<QueryBookArgs, 'id'>>;
  bookInfo?: Resolver<Maybe<ResolversTypes['BookInfo']>, ParentType, ContextType, RequireFields<QueryBookInfoArgs, 'id'>>;
  bookInfos?: Resolver<Array<Maybe<ResolversTypes['BookInfo']>>, ParentType, ContextType, RequireFields<QueryBookInfosArgs, 'ids'>>;
  books?: Resolver<Array<Maybe<ResolversTypes['Book']>>, ParentType, ContextType, RequireFields<QueryBooksArgs, 'ids'>>;
  debug_bookCounts?: Resolver<ResolversTypes['Debug_BookCounts'], ParentType, ContextType>;
  genres?: Resolver<Array<ResolversTypes['Genre']>, ParentType, ContextType>;
  relayBookInfos?: Resolver<ResolversTypes['BookInfoPartialList'], ParentType, ContextType, Partial<QueryRelayBookInfosArgs>>;
};

export type ReadResolvers<ContextType = any, ParentType extends ResolversParentTypes['Read'] = ResolversParentTypes['Read']> = {
  bookId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  infoId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  page?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReadListResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReadList'] = ResolversParentTypes['ReadList']> = {
  latestRevision?: Resolver<ResolversTypes['Revision'], ParentType, ContextType>;
  readList?: Resolver<Array<ResolversTypes['Read']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['Result'] = ResolversParentTypes['Result']> = {
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ResultWithBookResultsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResultWithBookResults'] = ResolversParentTypes['ResultWithBookResults']> = {
  bookResults?: Resolver<Maybe<Array<ResolversTypes['Result']>>, ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RevisionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Revision'] = ResolversParentTypes['Revision']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  syncedAt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {
  addBooks?: SubscriptionResolver<ResolversTypes['String'], "addBooks", ParentType, ContextType, RequireFields<SubscriptionAddBooksArgs, 'id'>>;
  bulkEditPage?: SubscriptionResolver<ResolversTypes['String'], "bulkEditPage", ParentType, ContextType, RequireFields<SubscriptionBulkEditPageArgs, 'id'>>;
};

export interface UploadScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Upload'], any> {
  name: 'Upload';
}

export type Resolvers<ContextType = any> = {
  AddBookInfoResult?: AddBookInfoResultResolvers<ContextType>;
  Auth0?: Auth0Resolvers<ContextType>;
  BigInt?: GraphQLScalarType;
  Book?: BookResolvers<ContextType>;
  BookInfo?: BookInfoResolvers<ContextType>;
  BookInfoEdge?: BookInfoEdgeResolvers<ContextType>;
  BookInfoList?: BookInfoListResolvers<ContextType>;
  BookInfoPartialList?: BookInfoPartialListResolvers<ContextType>;
  BookInfoThumbnail?: BookInfoThumbnailResolvers<ContextType>;
  Debug_BookCounts?: Debug_BookCountsResolvers<ContextType>;
  DeleteBookInfoResult?: DeleteBookInfoResultResolvers<ContextType>;
  EditBookInfoResult?: EditBookInfoResultResolvers<ContextType>;
  Genre?: GenreResolvers<ContextType>;
  IntRange?: GraphQLScalarType;
  Mutation?: MutationResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  Read?: ReadResolvers<ContextType>;
  ReadList?: ReadListResolvers<ContextType>;
  Result?: ResultResolvers<ContextType>;
  ResultWithBookResults?: ResultWithBookResultsResolvers<ContextType>;
  Revision?: RevisionResolvers<ContextType>;
  Subscription?: SubscriptionResolvers<ContextType>;
  Upload?: GraphQLScalarType;
};


export const schemaString = `schema{query:Query mutation:Mutation subscription:Subscription}type AddBookInfoResult{bookInfo:BookInfo code:String message:String success:Boolean!}type Auth0{clientId:String!domain:String!}scalar BigInt type Book{id:ID!info:BookInfo number:String!pages:Int!thumbnail:Int updatedAt:String!}type BookInfo{books(order:BookOrder=Number_Asc):[Book!]!count:Int!genres:[Genre!]!id:ID!name:String!thumbnail:BookInfoThumbnail updatedAt:String!}type BookInfoEdge{cursor:String!node:BookInfo!}type BookInfoList{hasNext:Boolean!infos:[BookInfo!]!}enum BookInfoOrder{Add_Newest Add_Oldest Name_Asc Name_Desc Update_Newest Update_Oldest}type BookInfoPartialList{edges:[BookInfoEdge!]!pageInfo:PageInfo!}type BookInfoThumbnail{bookId:ID!bookPageCount:Int!pageIndex:Int!}input BookInfosOption{genres:[String!]=[]order:BookInfoOrder=Update_Newest search:String searchMode:SearchMode=DATABASE}enum BookOrder{Number_Asc Number_Desc Update_Newest Update_Oldest}input CropEditAction{bottom:Int left:Int pageRange:IntRange!right:Int top:Int}type Debug_BookCounts{bookCount:Int!bookInfoCount:Int!}type DeleteBookInfoResult{books:[Book!]!code:String message:String success:Boolean!}input DeleteEditAction{pageRange:IntRange!}input EditAction{crop:CropEditAction delete:DeleteEditAction editType:EditType!hstack:HStackEditAction put:UploadEditAction replace:UploadEditAction split:SplitEditAction}type EditBookInfoResult{bookInfo:BookInfo code:String message:String success:Boolean!}enum EditType{Crop Delete HStack Put Replace Split}type Genre{invisible:Boolean!name:ID!}input HStackEditAction{pageRange:IntRange!}input InputBook{file:Upload number:String!path:String}input InputRead{bookId:ID!infoId:ID!page:Int!updatedAt:String!}scalar IntRange type Mutation{addBookInfo(genres:[String!]name:String!):AddBookInfoResult!addBooks(books:[InputBook!]!id:ID!):[Result!]!addCompressBook(file:Upload id:ID!path:String):ResultWithBookResults!bulkEditPage(actions:[EditAction!]!id:ID!):Result!debug_deleteUnusedFolders:Result!debug_rebuildMeiliSearch:Result!deleteBookInfo(id:ID!):DeleteBookInfoResult!deleteBooks(ids:[ID!]!infoId:ID!):Result!deleteGenre(genre:String!):Result!editBook(id:ID!number:String thumbnail:Int):Result!editBookInfo(genres:[String!]id:ID!name:String thumbnail:ID):EditBookInfoResult!editGenre(invisible:Boolean newName:String oldName:String!):Result!moveBooks(ids:[ID!]!infoId:ID!):Result!}type PageInfo{endCursor:String!hasNextPage:Boolean!hasPreviousPage:Boolean!startCursor:String!}type Query{availableSearchModes:[SearchMode!]!book(id:ID!):Book bookInfo(id:ID!):BookInfo bookInfos(ids:[ID!]!):[BookInfo]!books(ids:[ID!]!):[Book]!debug_bookCounts:Debug_BookCounts!genres:[Genre!]!relayBookInfos(after:String before:String first:Int last:Int option:BookInfosOption):BookInfoPartialList!}type Read{bookId:ID!infoId:ID!page:Int!updatedAt:String!}type ReadList{latestRevision:Revision!readList:[Read!]!}type Result{code:String message:String success:Boolean!}type ResultWithBookResults{bookResults:[Result!]code:String message:String success:Boolean!}type Revision{count:Int!syncedAt:String!}enum SearchMode{DATABASE ELASTICSEARCH MEILISEARCH}input SplitEditAction{pageRange:IntRange!splitCount:Int=2 splitType:SplitType!}enum SplitType{HORIZONTAL VERTICAL}type Subscription{addBooks(id:ID!):String!bulkEditPage(id:ID!):String!}scalar Upload input UploadEditAction{image:Upload!pageIndex:Int!}`;